## Implements the type-based pattern matching used by the code generated by
## parts of the nanopass framework.

import std/[macros]

type
  PChoice*[A, B] = object
    ## Predicate: T is `A` or `B`.

  PArray*[A] = object
    ## Predicate: T is array-like with element `A`.

macro dot(e, fname: untyped): untyped =
  ## ``dot(x, "abc")`` -> ``x.abc``.
  macro dotAux(fname: static string, e: untyped): untyped =
    newDotExpr(e, ident(fname))

  newCall(bindSym"dotAux", fname, e)

template matches*[T, U](x: T, _: typedesc[U]): bool =
  ## Implements type-based pattern matching, used by the nanopass macros.
  when U is PArray:
    when T is seq:
      matches(default(typeof(x[0])), typeof(U.A))
    else:
      false
  elif U is PChoice:
    # why not just use `or`? Because that would unnecessarily expand the
    # second `matches` invocation when the case first invocation was sucessful
    when matches(x, typeof(U.A)):
      true
    else:
      matches(x, typeof(U.B))
  elif U is Metavar:
    when x is U:
      true
    else:
      matches(x, dot(U.L.meta.nt, U.N))
  else:
    x is U
